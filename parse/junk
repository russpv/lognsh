static t_tok	*_match_normal(t_lex *lexer)
{
	debug_print( "_match_normal\n");
	struct s_ht_entry *res = NULL;
	int buf_idx = 0;

	while (' ' == *lexer->ptr)
		lexer->ptr++;
	if (true == _is_transition_char(*lexer->ptr))
		return (NULL);
	while (*lexer->ptr && false == _is_normal_delim(*lexer->ptr))
	{	
		_process_escape_sequence(lexer);
		if (1 == _process_special_operators(lexer))
			continue;
		lexer->buf[buf_idx++] = *lexer->ptr++;
   		fprintf(stderr, "Buffer content: '%s'\n", lexer->buf);  // Expecting a string with a single character
		res = ht_lookup(lexer->hasht, lexer->buf);
		if (res)
		{
			if (true == ((t_ht_data)(ht_get_payload(res)))->is_substring)
				res = _do_one_char_lookahead(lexer, res);	
			if (true == _is_normal_delim(*lexer->ptr))
				return (lex_create_token(lexer, ((t_ht_data)ht_get_payload(res))->type));
		}
	}
	if (true == _is_normal_delim(*lexer->ptr) && ft_strlen(lexer->buf) > 0)
		return (lex_create_token(lexer, _word_or_name(lexer->buf)));
	if ((unsigned char)OP_NULL == *lexer->ptr) // if delim is EOF
	{
		debug_print("##### FOUND NULL\n");
		return (NULL);
	}
	if (true == _is_normal_delim(*lexer->ptr)) // check if operator
	{
		lexer->buf[0] = *lexer->ptr++;
		res = ht_lookup(lexer->hasht, lexer->buf);
		if (res)
		{
			if (true == ((t_ht_data)(ht_get_payload(res)))->is_substring)
				res = _do_one_char_lookahead(lexer, res);	
			if (true == _is_normal_delim(*lexer->ptr))
				return (lex_create_token(lexer, ((t_ht_data)ht_get_payload(res))->type));
		}
	}
	return (NULL);
}